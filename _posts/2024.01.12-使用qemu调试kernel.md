---
title:  "使用qemu调试kernel"
search: true
categories:
  - kernel-dev
tags:
  - Linux
  - Kernel
toc: true
---

## 0 简介

qemu可以模拟各种架构的cpu、board, 也支持远程调试内核，使用qemu调试学习linux是
非常方便的。首先创建基于qemu/arm的调试虚拟环境，使用uboot作为bootloader，加载
linux内核，使用busybox构建根文件系统，提供内核和用户空间的基础运行环境。使用
qemu提供的arm virt系列Machine。

## 1 qemu源码编译

qemu源码：
  * archive: https://www.qemu.org/download/
  * git clone git://git.qemu-project.org/qemu.git

linux qemu编译：https://wiki.qemu.org/Hosts/Linux

```bash
#### requriment
sudo apt-get install build-essential
sudo apt-get install git libglib2.0-dev libfdt-dev libpixman-1-dev zlib1g-dev ninja-build
# sudo apt-get install git-email
sudo apt-get install libaio-dev libbluetooth-dev libcapstone-dev libbrlapi-dev libbz2-dev
sudo apt-get install libcap-ng-dev libcurl4-gnutls-dev libgtk-3-dev
sudo apt-get install libibverbs-dev libjpeg8-dev libncurses5-dev libnuma-dev
sudo apt-get install librbd-dev librdmacm-dev
sudo apt-get install libsasl2-dev libsdl2-dev libseccomp-dev libsnappy-dev libssh-dev
sudo apt-get install libvde-dev libvdeplug-dev libvte-2.91-dev libxen-dev liblzo2-dev
sudo apt-get install valgrind xfslibs-dev
sudo apt-get install flex bison

#### build
# Switch to the QEMU root directory.
cd qemu
# Prepare a native debug build.
mkdir -p bin/debug/native
cd bin/debug/native
# Configure QEMU and start the build.
../../../configure --enable-debug
make -j$(nproc)
# Return to the QEMU root directory.
cd ../../..

# target
./bin/debug/native/aarch64-softmmu/qemu-system-aarch64 -M help
./bin/debug/native/aarch64-softmmu/qemu-system-aarch64 -cpu help
```

## 2 uboot编译运行

uboot源码：`git clone https://github.com/u-boot/u-boot`

x86 host交叉编译：
  * 编译文档：https://docs.u-boot.org/en/latest/build/index.html#
  * 针对qemu virt的部分编译文档：https://github.com/ARM-software/u-boot/blob/master/doc/README.qemu-arm

```bash
#### requriment
sudo apt-get install gcc gcc-aarch64-linux-gnu
sudo apt-get install bc bison build-essential coccinelle \
  device-tree-compiler dfu-util efitools flex gdisk graphviz imagemagick \
  liblz4-tool libgnutls28-dev libguestfs-tools libncurses-dev \
  libpython3-dev libsdl2-dev libssl-dev lz4 lzma lzma-alone openssl \
  pkg-config python3 python3-asteval python3-coverage python3-filelock \
  python3-pkg-resources python3-pycryptodome python3-pyelftools \
  python3-pytest python3-pytest-xdist python3-sphinxcontrib.apidoc \
  python3-sphinx-rtd-theme python3-subunit python3-testtools \
  python3-virtualenv swig uuid-dev

#### build
mkdir build
CROSS_COMPILE=aarch64-linux-gnu- make O=build qemu_arm64_defconfig
CROSS_COMPILE=aarch64-linux-gnu- make O=build -j$(nproc)
```

编译完成后，在u-boot源码目录得到u-boot.bin，加载到qemu即可运行。
```bash
./bin/debug/native/aarch64-softmmu/qemu-system-aarch64 \
    -M virt -cpu cortex-a57 -m 1G \
    -serial stdio \
    -bios ~/projects/kernel-dev-qemu/u-boot.bin
```

去掉`-serial stdio`可以gui模式启动，同时查看qemu debug和serial。
<figure style="width: 500px" class="align-center">
  <a href="/assets/images/2024.01.12-使用qemu调试kernel/qemu-aarch64运行u-boot.png"><img src="/assets/images/2024.01.12-使用qemu调试kernel/qemu-aarch64运行u-boot.png"></a>
  <figcaption>图1. qemu-aarch64运行u-boot</figcaption>
</figure>

qemu virt平台支持Flash启动，Flash起始地址为`0x0000_0000`。在u-boot的编译结果目录制作flash.bin，把uboot可执行文件烧录到flash中启动。

```bash
dd if=/dev/zero of=flash.bin bs=4096 count=16384
dd if=u-boot.bin of=flash.bin conv=notrunc bs=4096

./bin/debug/native/aarch64-softmmu/qemu-system-aarch64 \
    -M virt -cpu cortex-a57 -m 1G \
    -serial stdio \
    -drive file=~/projects/kernel-dev-qemu/flash.bin,format=raw,if=pflash
```

## 3 编译GNU EFI

源码下载：git clone https://git.code.sf.net/p/gnu-efi/code gnu-efi

gnu-efi的文档README.gnuefi介绍了如何创建自己的efi程序。

```bash
CROSS_COMPILE=aarch64-linux-gnu- make -j$(nproc)
CROSS_COMPILE=aarch64-linux-gnu- make apps -j$(nproc)
```

编译出来的libs、apps efi都放在`./aarch64`子目录。加载第一个测试程序`t.efi`，输出
`hello world`。首先新建一个存放内核、根文件系统和EFI的虚拟disk。注意EFI固件存放的分区，

```bash
$ dd if=/dev/zero of=disk.img bs=4M count=2048

$ fdisk disk.img
Command (m for help): o
Created a new DOS disklabel with disk identifier 0x96f2fcbf.

Command (m for help): n
Partition type
   p   primary (0 primary, 0 extended, 4 free)
   e   extended (container for logical partitions)
Select (default p): p
Partition number (1-4, default 1): 1
First sector (2048-16777215, default 2048):
Last sector, +/-sectors or +/-size{K,M,G,T,P} (2048-16777215, default 16777215): +256M

Created a new partition 1 of type 'Linux' and of size 256 MiB.

Command (m for help): n
Partition type
   p   primary (1 primary, 0 extended, 3 free)
   e   extended (container for logical partitions)
Select (default p): p
Partition number (2-4, default 2):
First sector (526336-16777215, default 526336):
Last sector, +/-sectors or +/-size{K,M,G,T,P} (526336-16777215, default 16777215):

Created a new partition 2 of type 'Linux' and of size 7.7 GiB.

Command (m for help): t
Partition number (1,2, default 2): 1
Hex code or alias (type L to list all): b

Changed type of partition 'Linux' to 'W95 FAT32'.

Command (m for help): wq
The partition table has been altered.
Syncing disks.
```

把先前的`t.efi`重命名为`bootaa64.efi`，并放在disk.img分区1的`efi/boot`目录。

```bash
losetup -Pf disk.img
mkfs.vfat /dev/loop3p1
mkfs.ext4 /dev/loop3p1
mount /dev/loop3p1 mnt1
mount /dev/loop3p1 mnt2

./bin/debug/native/aarch64-softmmu/qemu-system-aarch64 \
    -M virt -cpu cortex-a57 -m 1G \
    -serial stdio \
    -drive file=~/projects/kernel-dev-qemu/flash.bin,format=raw,if=pflash \
    -drive file=~/projects/kernel-dev-qemu/disk.img,id=mydisk,format=raw,if=none \
    -device nvme,drive=mydisk,serial=foo
```

<figure style="width: 500px" class="align-center">
  <a href="/assets/images/2024.01.12-使用qemu调试kernel/qemu-aarch64启动efi.png"><img src="/assets/images/2024.01.12-使用qemu调试kernel/qemu-aarch64启动efi.png"></a>
  <figcaption>图1. qemu-aarch64运行u-boot</figcaption>
</figure>

## 4 编译arch64 kernel

下载内核源码，本次实验使用 v5.4 release 版本。

```bash
make ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu- defconfig
make ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu- menuconfig # menuconfig 可选
make ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu- Image -j$(nproc)
make ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu- dtbs -j$(nproc) # dts 可选
```

编译过程中，可能报错：` 'multiple definition of yylloc' `。解决办法是做出如下的修改：
```
diff --git a/scripts/dtc/dtc-lexer.l b/scripts/dtc/dtc-lexer.l
index 5c6c3fd557d7..3f942ce7f26d 100644
--- a/scripts/dtc/dtc-lexer.l
+++ b/scripts/dtc/dtc-lexer.l
@@ -23,7 +23,7 @@ LINECOMMENT   "//".*\n
 #include "srcpos.h"
 #include "dtc-parser.tab.h"
 
-YYLTYPE yylloc;
+extern YYLTYPE yylloc;
 extern bool treesource_error;
 
 /* CAUTION: this will stop working if we ever use yyless() or yyunput() */
 ```

 编译成功将得到 `arch/arm64/boot/Image` 内核镜像文件。接下来把内核镜像文件放到虚拟的 nvme 磁盘文件中。

 ```bash
sudo losetup -fP /path/to/your/nvme_disk.img
sudo partprobe /dev/loopX # 将 /dev/loopX 替换为 losetup 命令中分配的回环设备。
sudo mount /dev/loopXp1 /path/to/your/mnt
sudo cp arch/arm64/boot/Image /path/to/your/mnt/efi/
 ```
