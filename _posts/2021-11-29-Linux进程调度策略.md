---
title:  "Linux进程调度策略"
search: true
categories:
  - Linux内核的设计与实现
tags:
  - Linux
  - Kernel
header:
   teaser: /assets/images/2021-11-28-Linux内核简介/Linux_kernel_development.jpg
---

Linux的进程调度目标是最大限度利用处理器时间，并使系统间各个进程公平地使用处理器时间。

Linux内核支持抢占式多任务，由系统调度器来决定什么时候停止进程。非抢占式多任务需要程序主动放弃CPU时间，否则任务会一直运行下去。

## 程序调度策略/解决的问题

调度器的策略决定了系统的整体印象，优化进程使用处理器的时间，是系统中至关重要的部分。

### I/O消耗型和处理器消耗型的进程

I/O消耗型进程大部分时间用来提交I/O请求或等待I/O请求。这类程序经常处于可运行状态，但通常运行很短的时间，就会继续等待I/O阻塞。这类程序需要迅速响应。

处理器消耗型进程大部分时间用在执行代码上，通常都一直不停的运行。对于这类处理器消耗型的程序，调度器往往降低他们的调度频率，延长其运行时间。

调度器需要在进程响应迅速（响应时间短）和最大系统利用率（高吞吐量）之间取得平衡。Linux为了优先保障交互式应用程序和桌面系统的性能，倾向于优先调度I/O消耗型程序。

### 进程优先级

调度算法中最基本的一类就是基于优先级调度。实现方式是高优先级的进程先运行，同优先级的进程轮转运行。

Linux采用了两种不同的优先级范围。第一种是nice值，取值范围是-20到+19，默认为0。越大的nice值意味着更低的优先级。nice值是Unix系统的标准化概念。在Linux中，nice值代表进程分配时间片的比例。普通进程的nice值和实时调度策略SCHED_FIFO和SCHED_RR共享取值空间（0到MAX_RT_PRIO - 1），nice值的-20到+19对应MAX_RT_PRIO到MAX_RT_PRIO + 39的实时优先级。

第二种是实时优先级，值默认变化范围从0到99。越高的实时优先级数值代表着进程优先级越高。任何实时进程的优先级都高于普通进程。

### 时间片

调度策略必须规定一个默认的时间片。Linux中的CFS调度器没有直接分配时间片到进程，而是把处理器的使用比例划分给了进程。这个比例受到nice值得影响，越高的nice值分配越少的使用比。

在CFS调度器的策略中，进程抢占时机取决于新的可运行程序消耗了多少处理器使用比。如果进程消耗的使用比（实际运行时间/分配运行时间）小于当前进程，则新进程立即投入运行。

例如，I/O消耗型进程往往使用CPU时间很少，小于内核给它分配的处理器使用时间，导致进程实际消耗的使用比很小。当I/O进程唤醒时，内核就会优先调度该进程，达到公平分配处理器时间的目的，从而提高了系统的响应速度。

## Linux的调度算法

Linux调度器是以模块的方式提供的，能够支持不同的调度算法同时存在，目的是运行进程可以选择调度算法。每个调度器拥有自己的优先级，拥有可执行进程的最高优先级的调度器类，在调度时胜出，可以去选择要执行哪一个程序。

现代进程调度器有两个通用的概念：进程优先级和时间片。进程优先级nice值对应到时间片是一个复杂的问题。

### 公平调度CFS

CFS允许每个进程运行一段时间，循环轮转，选择运行时间最少的进程作为下一个运行进程，而不再给进程分配时间片。CFS在所有可运行进程总数基础上计算一个进程应该运行多久，而不是依靠nice值计算时间片。nice值在CFS中是进程获得处理器运行比的权重：越低的nice值获得更高的处理器使用权重。

CFS规定了每个进程获取时间片底线，默认情况下是1ms。绝对的nice值也不影响调度策略，内核使用可执行进程的相对nice值分配处理器时间比例。

## Linux调度算法的实现

### 时间记账

所有的调度器都要对进程运行时间记账。CFS虽然没有时间片的概念，但是也要对进程允许时间记账，确保进程只在公平分配的处理器时间内运行。进程描述符中结构体为struct sched_entity的变量se是调度器实体结构。

系统定时器周期调用`update_curr()`函数，根据系统当前所有可执行进程，加权更新当前进程的的处理器使用时间，存储在变量se的vruntime域中，以ns为计时单位。

### 进程选择

为了实现公平调度，CFS需要选择下一个运行程序时，总是挑具有最小vruntime的进程。CFS使用红黑树来组织可运行进程队列，来快速找到最小的vruntime进程。红黑树中最左边节点就是具有最小vruntime的进程，此节点会被缓存在rb_leftmost字段中。

进程调度的主要入口点函数时`schedule()`函数，该函数找到最高优先级的调度类，然后从该调度类选择下一个运行的进程。

### 进程睡眠和唤醒

进程阻塞时，需要在阻塞点将自己标记成休眠状态，从可执行红黑树移除，然后加入到等到队列中，最后调用`shedule()`选择其他进程执行。唤醒过程与此相反。

```c
DEFINE_WAIT(wait);
add_wait_queue(q, &wait);
while (!condition)
{
    prepare_to_wait(&q, &wait, TASK_INTERRUPTIBLE);
    if (signal_pending(current))
    {
        // 处理其他信号
    }
    schedule();
}
```

唤醒函数需要在达成条件的代码中调用`wake_up()`函数。

<figure style="width: 500px" class="align-center">
  <a href="/assets/images/2021-11-28-Linux进程调度策略/sleep_and_wakeup.png"><img src="/assets/images/2021-11-28-Linux进程调度策略/sleep_and_wakeup.png"></a>
  <figcaption>图1. 休眠与唤醒</figcaption>
</figure>

## 抢占和上下文切换

上下文切换包括进程的虚拟内存切换和处理器状态切换。除了进程显式调用`schedule()`函数，内核还提供一个need_resched标志表示是否需要重新执行一次调度。这个标志存在于每个进程的进程描述符中，访问进程描述符内的数值比访问全局变量快。

当内核即将返回用户空间时，如果need_resched标志被设置，会发生**用户抢占**。用户抢占在系统调用返回用户空间、中断处理程序返回用户空间时可以发生。

Linux完整地支持**内核抢占**，只要没有持有锁，内核就可以进行抢占（为了调度安全）。每个进程的thread_info中有preempt_count计数器，初始值为0，每当使用锁时加1，释放锁时减1。只有数值减到0的时候，内核才可以抢占。内核抢占在中断程序返回内核空间前、内核代码再一次具有可强制性时、内核任务显式调用schedule()、内核中的任务阻塞时可以发生。

## 实时调度策略

Linux提供了两种实时调度策略：SCHED_FIFO和SCHED_RR。普通的非实时调度是SCHED_NORMAL。SCHED_FIFO是一种简单的先入先出调度算法，不使用时间片。SCHED_FIFO的进程优先级高于任何SCHED_NORMAL进程，总是先于普通进程被调度。仅有更高有限级的SCHED_FIFO或SCHED_RR进程可以抢占当前SCHED_FIFO进程，否则SCHED_FIFO进程不主动退出的话，会一直运行下去。对于同优先级的多个SCHED_FIFO进程，在一个同级别的进程主动退出后，才会轮流执行下一个进程。

SCHED_RR级进程是带有时间片的SCHED_FIFO进程，时间片只用来重新调度同一优先级的进程。这是一种实时轮流调度算法。

这两种算法都是静态优先级，为Linux内核提供了一种软实时的工作方式。优先级返回从0到MAX_RT_PRIO - 1，MAX_RT_PRIO默认是100。