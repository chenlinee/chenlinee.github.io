---
title:  "Linux内核内建数据结构"
search: true
categories:
  - Linux内核的设计与实现
tags:
  - Linux
  - Kernel
header:
   teaser: /assets/images/2021-11-28-Linux内核简介/Linux_kernel_development.jpg
---

内核开发用的C语言不具有对象属性，复用相似数据结构代码并不方便。Linux内核巧妙地内建常用数据结构，实现了类似C++模板类的功能。这些内建数据结构包括链表、队列、映射、二叉树。

## 链表

Linux内核实现链表的方式与众不同，它不是将数据结构塞入链表，而是将链表节点塞入数据结构。这意味着，链表的前后节点对应的父结构体可以不一样。

### 链表数据结构

链表代码在头文件`<linux/list.h>`中声明：

```c
struct list_head {
    struct list_head *next;
    struct list_prev *prev;
};
```

next指向下一个链表节点的list_head域，prev指向前一个。例如：

```c
struct fox {
    unsigned long     tail_length;
    unsigned long     weight;
    struct list_head  list;
};
```

这就定义了一个可用的链表数据结构。Linux内核还定义了一组链表操作例程。宏`container_of()`可以方便的从链表指针找到父节点的任何变量。这是因为C语言中，结构中的变量在编译时偏移地址就确定下来了。宏`list_entry()`是宏`container_of()`的封装，可以返回包含list_head结构体的父类型结构体。

```c
#define container_of(ptr, type, member) ({                      \
        const typeof( {(type *)0}->member ) *__mptr = (ptr);    \
        (type *)( (char *)__mptr - offsetof(type, member)) );})

#define list_entry(ptr, type, member) \   // type是结构体名称
        constainer_of(ptr, type, member)  // member是链表域在这个结构体中的名称
```

### 定义链表

链表在使用之前需要初始化。

```c
// 动态创建
struct fox *red_fox;
red_fox = kmalloc(sizeof(*red_fox), GFP_KERNEL);
INIT_LIST_HEAD(&red_fox->list);
// 静态创建
struct fox red_fox = {
    .tail_length = 40;
    .weight = 6;
    .list = LIST_HEAD_INIT(red_fox.list);
}
```

双向循环链表每一个节点都没有差别，但是Linux内核支持添加特殊的头结点：
```c
static LIST_HEAD(fox_list);
```
`<linux/list.h>`头文件中，对LIST_HEAD()的定义如下：
```c
struct list_head {
    struct list_head *next, *prev;
};

#define LIST_HEAD_INIT(name) {&(name), &(name)} 

#define LIST_HEAD(name) \ //定义并初始化头结点head
    struct list_head name = LIST_HEAD_INIT(name)
```

### 操作链表

内核提供一组函数操作链表，包括了添加、删除、移动节点等操作。

```c
/** 添加节点
 * @new: new entry to be added
 * @head: list head to add it before
 */
list_add_tail(struct list_head *new, struct list_head *head)

/** 仅从链表取下节点，不删除数据结构
 * @entry: the element to delete from the list.
 */
list_del(struct list_head *entry)
list_del_init(struct list_head *entry)

/** 把节点从一个链表移动到另一个链表
 * @list: the entry to move
 * @head: the head that will precede our entry
 */
list_move(struct list_head *list, struct list_head *head)

/** 只有按照内核接口操作的链表，判断结果才是正确的
 * 判断链表是否空
 * @head: the list to test.
 */
static inline int list_empty(const struct list_head *head)
{
    return head->next == head;
}

/** 拼接两个链表
 * @list: the new list to add.
 * @head: the place to add it in the first list.
 */
static inline void list_splice(const struct list_head *list,
				struct list_head *head)
```

### 遍历链表

链表遍历需要前面提到的链表头，内核提供了`list_for_each()`, `list_for_each_entry()`, `list_for_each_entry_reverse()`, `list_for_each_entry_safe()`等宏定义，满足不通的需求。

* `list_for_each()`  
  用法`list_for_each(p, list)`，其中p是父结构体中的链表域指针，list是特殊的链表头。可以在循环体中用`list_entry()`宏获取父结构体。
* `list_for_each_entry()`, `list_for_each_entry_reverse()`  
  用法`list_for_each(pos, head, member)`，其中pos是父结构体指针，head是特殊链表头结点，member是父结构体中链表域的名字。循环体中直接获得指向父结构体的指针。
* `list_for_each_entry_safe()`  
  标准链表操作在遍历链表时，不能删除链表的节点（删除导致next无法继续）。这个宏在操作之前就保存了next指针，以便执行删除操作。这智能保护当前循环中安全删除链表中数据，但是无法避免并发执行的其他地方删除链表数据，导致的链表遍历错误。

## 队列